<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ra_hir_ty` crate."><meta name="keywords" content="rust, rustlang, rust-lang, ra_hir_ty"><title>ra_hir_ty - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../ra_hir_ty/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate ra_hir_ty</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all ra_hir_ty's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'ra_hir_ty', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/ra_hir_ty/lib.rs.html#1-936' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>ra_hir_ty</a></span></h1><div class='docblock'><p>The type system. We currently use this to infer types for completion, hover
information and various assists.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use traits::<a class="struct" href="../ra_hir_ty/traits/struct.InEnvironment.html" title="struct ra_hir_ty::traits::InEnvironment">InEnvironment</a>;</code></td></tr><tr><td><code>pub use traits::<a class="enum" href="../ra_hir_ty/traits/enum.Obligation.html" title="enum ra_hir_ty::traits::Obligation">Obligation</a>;</code></td></tr><tr><td><code>pub use traits::<a class="struct" href="../ra_hir_ty/traits/struct.ProjectionPredicate.html" title="struct ra_hir_ty::traits::ProjectionPredicate">ProjectionPredicate</a>;</code></td></tr><tr><td><code>pub use traits::<a class="struct" href="../ra_hir_ty/traits/struct.TraitEnvironment.html" title="struct ra_hir_ty::traits::TraitEnvironment">TraitEnvironment</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="db/index.html" title='ra_hir_ty::db mod'>db</a></td><td class='docblock-short'><p>FIXME: write short doc here</p>
</td></tr><tr class='module-item'><td><a class="mod" href="diagnostics/index.html" title='ra_hir_ty::diagnostics mod'>diagnostics</a></td><td class='docblock-short'><p>FIXME: write short doc here</p>
</td></tr><tr class='module-item'><td><a class="mod" href="display/index.html" title='ra_hir_ty::display mod'>display</a></td><td class='docblock-short'><p>FIXME: write short doc here</p>
</td></tr><tr class='module-item'><td><a class="mod" href="expr/index.html" title='ra_hir_ty::expr mod'>expr</a></td><td class='docblock-short'><p>FIXME: write short doc here</p>
</td></tr><tr class='module-item'><td><a class="mod" href="method_resolution/index.html" title='ra_hir_ty::method_resolution mod'>method_resolution</a></td><td class='docblock-short'><p>This module is concerned with finding methods that a given type provides.
For details about how this works in rustc, see the method lookup page in the
<a href="https://rust-lang.github.io/rustc-guide/method-lookup.html">rustc guide</a>
and the corresponding code mostly in librustc_typeck/check/method/probe.rs.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="primitive/index.html" title='ra_hir_ty::primitive mod'>primitive</a></td><td class='docblock-short'><p>Defines primitive types, which have a couple of peculiarities:</p>
</td></tr><tr class='module-item'><td><a class="mod" href="traits/index.html" title='ra_hir_ty::traits mod'>traits</a></td><td class='docblock-short'><p>Trait solving using Chalk.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.ApplicationTy.html" title='ra_hir_ty::ApplicationTy struct'>ApplicationTy</a></td><td class='docblock-short'><p>A nominal type with (maybe 0) type parameters. This might be a primitive
type like <code>bool</code>, a struct, tuple, function pointer, reference or
several other things.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Binders.html" title='ra_hir_ty::Binders struct'>Binders</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.BoundVar.html" title='ra_hir_ty::BoundVar struct'>BoundVar</a></td><td class='docblock-short'><p>Identifies a particular bound variable within a binder.
Variables are identified by the combination of a [<code>DebruijnIndex</code>],
which identifies the <em>binder</em>, and an index within that binder.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Canonical.html" title='ra_hir_ty::Canonical struct'>Canonical</a></td><td class='docblock-short'><p>Basically a claim (currently not validated / checked) that the contained
type / trait ref contains no inference variables; any inference variables it
contained have been replaced by bound variables, and <code>num_vars</code> tells us how
many there are. This is used to erase irrelevant differences between types
before using them in queries.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.DebruijnIndex.html" title='ra_hir_ty::DebruijnIndex struct'>DebruijnIndex</a></td><td class='docblock-short'><p>References the binder at the given depth. The index is a <a href="https://en.wikipedia.org/wiki/De_Bruijn_index">de
Bruijn index</a>, so it counts back through the in-scope binders,
with 0 being the innermost binder. This is used in impls and
the like. For example, if we had a rule like <code>for&lt;T&gt; { (T: Clone) :- (T: Copy) }</code>, then <code>T</code> would be represented as a
<code>BoundVar(0)</code> (as the <code>for</code> is the innermost binder).</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.FnSig.html" title='ra_hir_ty::FnSig struct'>FnSig</a></td><td class='docblock-short'><p>A function signature as seen by type inference: Several parameter types and
one return type.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.InferenceResult.html" title='ra_hir_ty::InferenceResult struct'>InferenceResult</a></td><td class='docblock-short'><p>The result of type inference: A mapping from expressions and patterns to types.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ProjectionTy.html" title='ra_hir_ty::ProjectionTy struct'>ProjectionTy</a></td><td class='docblock-short'><p>A &quot;projection&quot; type corresponds to an (unnormalized)
projection like <code>&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::Foo</code>. Note that the
trait and all its parameters are fully known.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.Substs.html" title='ra_hir_ty::Substs struct'>Substs</a></td><td class='docblock-short'><p>A list of substitutions for generic parameters.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.SubstsBuilder.html" title='ra_hir_ty::SubstsBuilder struct'>SubstsBuilder</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.TraitRef.html" title='ra_hir_ty::TraitRef struct'>TraitRef</a></td><td class='docblock-short'><p>A trait with type parameters. This includes the <code>Self</code>, so this represents a concrete type implementing the trait.
Name to be bikeshedded: TraitBound? TraitImplements?</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.TyLoweringContext.html" title='ra_hir_ty::TyLoweringContext struct'>TyLoweringContext</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="struct" href="struct.TypeCtorId.html" title='ra_hir_ty::TypeCtorId struct'>TypeCtorId</a></td><td class='docblock-short'><p>This exists just for Chalk, because Chalk just has a single <code>StructId</code> where
we have different kinds of ADTs, primitive types and special type
constructors like tuples and function pointers.</p>
</td></tr></table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table><tr class='module-item'><td><a class="enum" href="enum.CallableDef.html" title='ra_hir_ty::CallableDef enum'>CallableDef</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.GenericPredicate.html" title='ra_hir_ty::GenericPredicate enum'>GenericPredicate</a></td><td class='docblock-short'><p>Like <code>generics::WherePredicate</code>, but with resolved types: A condition on the
parameters of a generic item.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ImplTraitLoweringMode.html" title='ra_hir_ty::ImplTraitLoweringMode enum'>ImplTraitLoweringMode</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.InferTy.html" title='ra_hir_ty::InferTy enum'>InferTy</a></td><td class='docblock-short'><p>The kinds of placeholders we need during type inference. There's separate
values for general types, and for integer and float variables. The latter
two are used for inference of literal values (e.g. <code>100</code> could be one of
several integer types).</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.Ty.html" title='ra_hir_ty::Ty enum'>Ty</a></td><td class='docblock-short'><p>A type.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.TyDefId.html" title='ra_hir_ty::TyDefId enum'>TyDefId</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="enum" href="enum.TypeCtor.html" title='ra_hir_ty::TypeCtor enum'>TypeCtor</a></td><td class='docblock-short'><p>A type constructor or type name: this might be something like the primitive
type <code>bool</code>, a struct like <code>Vec</code>, or things like function pointers or
tuples.</p>
</td></tr><tr class='module-item'><td><a class="enum" href="enum.ValueTyDefId.html" title='ra_hir_ty::ValueTyDefId enum'>ValueTyDefId</a></td><td class='docblock-short'></td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.TypeWalk.html" title='ra_hir_ty::TypeWalk trait'>TypeWalk</a></td><td class='docblock-short'><p>This allows walking structures that contain types to do something with those
types, similar to Chalk's <code>Fold</code> trait.</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.autoderef.html" title='ra_hir_ty::autoderef fn'>autoderef</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.callable_item_sig.html" title='ra_hir_ty::callable_item_sig fn'>callable_item_sig</a></td><td class='docblock-short'><p>Build the signature of a callable item (function, struct or enum variant).</p>
</td></tr></table><h2 id='types' class='section-header'><a href="#types">Type Definitions</a></h2>
<table><tr class='module-item'><td><a class="type" href="type.PolyFnSig.html" title='ra_hir_ty::PolyFnSig type'>PolyFnSig</a></td><td class='docblock-short'><p>A polymorphic function signature.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "ra_hir_ty";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>